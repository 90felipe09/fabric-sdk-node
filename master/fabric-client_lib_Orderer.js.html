<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: fabric-client/lib/Orderer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: fabric-client/lib/Orderer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * SPDX-License-Identifier: Apache-2.0
 */

'use strict';

const {Utils: utils} = require('fabric-common');
const Remote = require('./Remote');

const fabprotos = require('fabric-protos');
const logger = utils.getLogger('Orderer.js');

/**
 * @typedef {Error} SYSTEM_TIMEOUT The Error message string that indicates that
 *           the request operation has timed out due to a system issue. This will
 *           indicate that the issue is local rather than remote. If there is
 *           an issue with the remote node a 'REQUEST_TIMEOUT' error message
 *           will be returned.
 *           The operation will only use one timer for both types of timeouts.
 *           The timer will start running as the operation begins. If the timer
 *           expires before the local instance is able to make the outbound
 *           request then 'SYSTEM_TIMEOUT' error will be returned. If the local
 *           instance is able to make the outbound request and the timer expires
 *           before the remote node responds then the 'REQUEST_TIMEOUT' is
 *           returned. The timer is controlled by the 'request-timeout' setting
 *           or passed on a call that makes an outbound request
 *           @example 'client.setConfigSetting('request-timeout', 3000)'
 *           @example 'channel.sendTranaction(request, 3000)'
 */

/**
 * @typedef {Error} REQUEST_TIMEOUT The Error message string that indicates that
 *           the request operation has timed out due to a remote node issue.
 *           If there is an issue with the local system a 'SYSTEM_TIMEOUT'
 *           error message will be returned.
 *           The operation will only use one timer for both types of timeouts.
 *           The timer will start running as the operation begins. If the timer
 *           expires before the local instance is able to make the outbound
 *           request then 'SYSTEM_TIMEOUT' error will be returned. If the local
 *           instance is able to make the outbound request and the timer expires
 *           before the remote node responds then the 'REQUEST_TIMEOUT' is
 *           returned. The timer is controlled by the 'request-timeout' setting
 *           or passed on a call that makes an outbound request
 *           @example 'client.setConfigSetting('request-timeout', 3000)'
 *           @example 'channel.sendTranaction(request, 3000)'
 */

/**
 * The Orderer class encapsulates the client capabilities to interact with
 * an Orderer node in the target blockchain network. The orderer node exposes
 * two APIs: broadcast() and deliver(). Both are streaming APIs so there's
 * a persistent grpc streaming connection between the client and the orderer
 * where messages are exchanged in both directions. The broadcast() API is
 * for sending transactions to the orderer for processing. The deliver() API
 * is for asking the orderer for information such as channel configurations.
 *
 * @class
 * @extends Remote
 */
class Orderer extends Remote {

	/**
	 * Constructs an Orderer object with the given url and opts. An orderer object
	 * encapsulates the properties of an orderer node and the interactions with it via
	 * the grpc stream API. Orderer objects are used by the {@link Client} objects to broadcast
	 * requests for creating and updating channels. They are also used by the {@link Channel}
	 * objects to broadcast requests for ordering transactions.
	 *
	 * @param {string} url The URL with format of "grpc(s)://host:port".
	 * @param {ConnectionOpts} opts The options for the connection to the orderer.
	 * @returns {Orderer} The Orderer instance.
	 */
	constructor(url, opts) {
		super(url, opts);

		logger.debug('Orderer.const - url: %s timeout: %s', url, this._request_timeout);
		this._ordererClient = new fabprotos.orderer.AtomicBroadcast(this._endpoint.addr, this._endpoint.creds, this._options);
		this._sendDeliverConnect = false;
	}

	/**
	 * Close the service connection.
	 */
	close() {
		if (this._ordererClient) {
			logger.debug('close - closing orderer connection ' + this._endpoint.addr);
			this._ordererClient.close();
		}
	}

	/**
	 * @typedef {Object} BroadcastResponse
	 * @property {string} status - Value is 'SUCCESS' or a descriptive error string
	 * @property {string} info - Optional. Additional information about the status
	 */

	/**
	 * Send a Broadcast message to the orderer service.
	 *
	 * @param {byte[]} envelope - Byte data to be included in the broadcast.
	 *        This must be a protobuf encoded byte array of the
	 *        [common.Envelope]{@link https://github.com/hyperledger/fabric/blob/v1.0.0/protos/common/common.proto#L132}
	 *        that contains either a [ConfigUpdateEnvelope]{@link https://github.com/hyperledger/fabric/blob/v1.0.0/protos/common/configtx.proto#L70}
	 *        or a [Transaction]{@link https://github.com/hyperledger/fabric/blob/v1.0.0/protos/peer/transaction.proto#L70}
	 *        in the &lt;code>payload.data&lt;/code> property of the envelope.
	 * @param {Number} timeout - A number indicating milliseconds to wait on the
	 *        response before rejecting the promise with a timeout error. This
	 *        overrides the default timeout of the Peer instance and the global
	 *        timeout in the config settings.
	 * @returns {Promise} A Promise for a {@link BroadcastResponse} object
	 * @throws {SYSTEM_TIMEOUT | REQUEST_TIMEOUT}
	 */
	sendBroadcast(envelope, timeout) {
		logger.debug('sendBroadcast - start');

		if (!envelope || envelope === '') {
			logger.debug('sendBroadcast ERROR - missing envelope');
			const err = new Error('Missing data - Nothing to broadcast');
			return Promise.reject(err);
		}

		const self = this;
		let rto = self._request_timeout;
		if (typeof timeout === 'number') {
			rto = timeout;
		}

		return this.waitForReady(this._ordererClient).then(() => {
			// Send the envelope to the orderer via grpc
			return new Promise((resolve, reject) => {
				const broadcast = self._ordererClient.broadcast();
				let error_msg = 'SYSTEM_TIMEOUT';

				const broadcast_timeout = setTimeout(() => {
					logger.error('sendBroadcast - timed out after:%s', rto);
					broadcast.end();
					return reject(new Error(error_msg));
				}, rto);

				broadcast.on('data', (response) => {
					logger.debug('sendBroadcast - on data response: %j', response);
					broadcast.end();
					if (response &amp;&amp; response.info) {
						logger.debug('sendBroadcast - response info :: %s', response.info);
					}
					if (response &amp;&amp; response.status) {
						logger.debug('sendBroadcast - response status %s', response.status);
						return resolve(response);
					} else {
						logger.error('sendBroadcast ERROR - reject with invalid response from the orderer');
						return reject(new Error('SYSTEM_ERROR'));
					}
				});

				broadcast.on('end', () => {
					logger.debug('sendBroadcast - on end:');
					clearTimeout(broadcast_timeout);
					broadcast.cancel();
				});

				broadcast.on('error', (err) => {
					clearTimeout(broadcast_timeout);
					broadcast.end();
					if (err &amp;&amp; err.code) {
						if (err.code === 14) {
							logger.error('sendBroadcast - on error: %j', err.stack ? err.stack : err);
							return reject(new Error('SERVICE_UNAVAILABLE'));
						}
					}
					logger.error('sendBroadcast - on error: %j', err.stack ? err.stack : err);
					return reject(err);
				});

				broadcast.write(envelope);
				error_msg = 'REQUEST_TIMEOUT';
				logger.debug('sendBroadcast - sent message');
			});
		},
		(error) => {
			logger.error('Orderer %s has an error %s ', self.getUrl(), error.toString());
			return Promise.reject(error);
		});
	}

	/**
	 * Send a Deliver message to the orderer service.
	 *
	 * @param {byte[]} envelope - Byte data to be included in the broadcast. This must
	 *                            be a protobuf encoded byte array of the
	 *                            [common.Envelope]{@link https://github.com/hyperledger/fabric/blob/v1.0.0/protos/common/common.proto#L132}
	 *                            that contains a [SeekInfo]{@link https://github.com/hyperledger/fabric/blob/v1.0.0/protos/orderer/ab.proto#L54}
	 *                            in the &lt;code>payload.data&lt;/code> property of the envelope.
	 *                            The &lt;code>header.channelHeader.type&lt;/code> must be set to
	 *                            [common.HeaderType.DELIVER_SEEK_INFO]{@link https://github.com/hyperledger/fabric/blob/v1.0.0/protos/common/common.proto#L44}
	 * @returns {Promise} A Promise for a protobuf object of type common.Block. Note that this
	 *                    is &lt;b>NOT&lt;/b> the same type of object as the {@link Block} returned by the
	 *                    [BlockDecoder.decode()]{@link BlockDecode.decode} method and various
	 *                    other methods. A {@link Block} is a pure javascript object, whereas
	 *                    the object returned by this method is a protobuf object that contains
	 *                    accessor methods, getters and setters, and toBuffer() for each property
	 *                    to be used for further manipulating the object and convert to and from
	 *                    byte arrays.
	 * @throws {SYSTEM_TIMEOUT | REQUEST_TIMEOUT}
	 */
	sendDeliver(envelope) {
		logger.debug('sendDeliver - start');

		if (!envelope) {
			logger.debug('sendDeliver ERROR - missing envelope');
			const err = new Error('Missing data - Nothing to deliver');
			return Promise.reject(err);
		}

		const self = this;

		return this.waitForReady(this._ordererClient).then(() => {
			// Send the seek info to the orderer via grpc
			return new Promise((resolve, reject) => {
				try {
					const deliver = self._ordererClient.deliver();
					let return_block = null;
					self._sendDeliverConnect = false;
					let error_msg = 'SYSTEM_TIMEOUT';

					const deliver_timeout = setTimeout(() => {
						logger.debug('sendDeliver - timed out after:%s', self._request_timeout);
						deliver.end();
						return reject(new Error(error_msg));
					}, self._request_timeout);
					deliver.on('data', (response) => {
						logger.debug('sendDeliver - on data'); // response: %j', response);
						// check the type of the response
						if (response.Type === 'block') {
							const blockHeader = new fabprotos.common.BlockHeader();
							blockHeader.setNumber(response.block.header.number);
							blockHeader.setPreviousHash(response.block.header.previous_hash);
							blockHeader.setDataHash(response.block.header.data_hash);
							const blockData = new fabprotos.common.BlockData();
							blockData.setData(response.block.data.data);
							const blockMetadata = new fabprotos.common.BlockMetadata();
							blockMetadata.setMetadata(response.block.metadata.metadata);

							const block = new fabprotos.common.Block();
							block.setHeader(blockHeader);
							block.setData(blockData);
							block.setMetadata(blockMetadata);
							return_block = block;

							logger.debug('sendDeliver - wait for success, keep this block number %s', return_block.header.number);
						} else if (response.Type === 'status') {
							clearTimeout(deliver_timeout);
							self._sendDeliverConnect = false;
							deliver.end();
							// response type should now be 'status'
							if (response.status === 'SUCCESS') {
								logger.debug('sendDeliver - resolve - status:%s', response.status);
								return resolve(return_block);
							} else {
								logger.error('sendDeliver - rejecting - status:%s', response.status);
								return reject(new Error('Invalid results returned ::' + response.status));
							}
						} else {
							logger.error('sendDeliver ERROR - reject with invalid response from the orderer');
							clearTimeout(deliver_timeout);
							deliver.end();
							self._sendDeliverConnect = false;
							return reject(new Error('SYSTEM_ERROR'));
						}
					});

					deliver.on('status', (response) => {
						logger.debug('sendDeliver - on status:%j', response);
					});

					deliver.on('end', () => {
						logger.debug('sendDeliver - on end');
						if (self._sendDeliverConnect) {
							clearTimeout(deliver_timeout);
							deliver.cancel();
							self._sendDeliverConnect = false;
						}

					});

					deliver.on('error', (err) => {
						logger.debug('sendDeliver - on error');
						clearTimeout(deliver_timeout);
						if (self._sendDeliverConnect) {
							deliver.end();
							self._sendDeliverConnect = false;
							if (err &amp;&amp; err.code) {
								if (err.code === 14) {
									logger.error('sendDeliver - on error code 14: %j', err.stack ? err.stack : err);
									return reject(new Error('SERVICE_UNAVAILABLE'));
								}
							}
						}
						return reject(err);
					});

					deliver.write(envelope);
					error_msg = 'REQUEST_TIMEOUT';
					self._sendDeliverConnect = true;
					logger.debug('sendDeliver - sent envelope');
				} catch (error) {
					logger.error('sendDeliver - system error ::' + (error.stack ? error.stack : error));
					if (error instanceof Error) {
						return reject(error);
					} else {
						return reject(new Error(error));
					}
				}
			});
		});
	}

	/**
	 * return a printable representation of this object
	 */
	toString() {
		return 'Orderer:{' +
            'url:' + this._url +
            '}';
	}
}

module.exports = Orderer;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-fabric-network.html">fabric-network</a></li></ul><h3>Classes</h3><ul><li><a href="AffiliationService.html">AffiliationService</a></li><li><a href="BasePackager.html">BasePackager</a></li><li><a href="BasicCommitHandler.html">BasicCommitHandler</a></li><li><a href="BlockDecoder.html">BlockDecoder</a></li><li><a href="CertificateAuthority.html">CertificateAuthority</a></li><li><a href="Chaincode.html">Chaincode</a></li><li><a href="ChaincodeRegistration.html">ChaincodeRegistration</a></li><li><a href="Channel.html">Channel</a></li><li><a href="ChannelEventHub.html">ChannelEventHub</a></li><li><a href="ChannelPeer.html">ChannelPeer</a></li><li><a href="Client.html">Client</a></li><li><a href="CommitHandler.html">CommitHandler</a></li><li><a href="DiscoveryEndorsementHandler.html">DiscoveryEndorsementHandler</a></li><li><a href="EndorsementHandler.html">EndorsementHandler</a></li><li><a href="EndorsementPolicy.html">EndorsementPolicy</a></li><li><a href="Endpoint.html">Endpoint</a></li><li><a href="event_hub_number.html">event_hub_number</a></li><li><a href="FabricCAClient.html">FabricCAClient</a></li><li><a href="FabricCAServices.html">FabricCAServices</a></li><li><a href="IdentityService.html">IdentityService</a></li><li><a href="module-fabric-network.AbstractEventHubSelectionStrategy.html">AbstractEventHubSelectionStrategy</a></li><li><a href="module-fabric-network.AbstractEventListener.html">AbstractEventListener</a></li><li><a href="module-fabric-network.BaseCheckpointer.html">BaseCheckpointer</a></li><li><a href="module-fabric-network.CommitEventListener.html">CommitEventListener</a></li><li><a href="module-fabric-network.Contract.html">Contract</a></li><li><a href="module-fabric-network.ContractEventListener.html">ContractEventListener</a></li><li><a href="module-fabric-network.EventHubDisconnectError.html">EventHubDisconnectError</a></li><li><a href="module-fabric-network.EventHubManager.html">EventHubManager</a></li><li><a href="module-fabric-network.FabricError.html">FabricError</a></li><li><a href="module-fabric-network.FileSystemCheckpointer.html">FileSystemCheckpointer</a></li><li><a href="module-fabric-network.Gateway.html">Gateway</a></li><li><a href="module-fabric-network.HsmX509Provider.html">HsmX509Provider</a></li><li><a href="module-fabric-network.IdentityProviderRegistry.html">IdentityProviderRegistry</a></li><li><a href="module-fabric-network.Network.html">Network</a></li><li><a href="module-fabric-network.Query.html">Query</a></li><li><a href="module-fabric-network.RoundRobinEventHubSelectionStrategy.html">RoundRobinEventHubSelectionStrategy</a></li><li><a href="module-fabric-network.TimeoutError.html">TimeoutError</a></li><li><a href="module-fabric-network.Transaction.html">Transaction</a></li><li><a href="module-fabric-network.Wallet.html">Wallet</a></li><li><a href="module-fabric-network.Wallets.html">Wallets</a></li><li><a href="MSP.html">MSP</a></li><li><a href="MSPManager.html">MSPManager</a></li><li><a href="NetworkConfig_1_0.html">NetworkConfig_1_0</a></li><li><a href="Orderer.html">Orderer</a></li><li><a href="Organization.html">Organization</a></li><li><a href="Peer.html">Peer</a></li><li><a href="Remote.html">Remote</a></li><li><a href="TransactionID.html">TransactionID</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-fabric-network.WalletStore.html">WalletStore</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-app-dev-env-setup.html">Setting up the Application Developer's Environment</a></li><li><a href="tutorial-chaincode-lifecycle.html">fabric-client: How to install and start your chaincode</a></li><li><a href="tutorial-channel-create.html">fabric-client: How to create a Hyperledger Fabric channel</a></li><li><a href="tutorial-channel-events.html">fabric-client: How to use the channel-based event service</a></li><li><a href="tutorial-discovery.html">fabric-client: How to use the discovery service</a></li><li><a href="tutorial-event-checkpointer.html">fabric-network: How to replay missed events</a></li><li><a href="tutorial-event-hub-management.html">fabric-network: How to automatically select and reconnect to event hubs</a></li><li><a href="tutorial-grpc-settings.html">fabric-client: How to set gRPC settings</a></li><li><a href="tutorial-handlers.html">fabric-client: How to use the endorsement and commit handlers</a></li><li><a href="tutorial-listening-to-events.html">fabric-network: How to listen to events</a></li><li><a href="tutorial-logging.html">fabric-client: How to use logging</a></li><li><a href="tutorial-metadata-chaincode.html">fabric-client: How to add CouchDB indexes during chaincode installation</a></li><li><a href="tutorial-mutual-tls.html">fabric-client: How to configure mutual TLS</a></li><li><a href="tutorial-network-config.html">fabric-client: How to use a common connection profile</a></li><li><a href="tutorial-private-data.html">How to use private data</a></li><li><a href="tutorial-query-peers.html">fabric-network: How to select peers for evaluating transactions (queries)</a></li><li><a href="tutorial-sign-transaction-offline.html">Working with an offline private key</a></li><li><a href="tutorial-transaction-commit-events.html">fabric-network: How to wait for transactions to be committed to the ledger</a></li><li><a href="tutorial-wallet.html">fabric-network: Using wallets to manage identities</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CLIENT">CLIENT</a></li><li><a href="global.html#finalPackage">finalPackage</a></li><li><a href="global.html#HFAFFILIATIONMGR">HFAFFILIATIONMGR</a></li><li><a href="global.html#HFGENCRL">HFGENCRL</a></li><li><a href="global.html#HFINTERMEDIATECA">HFINTERMEDIATECA</a></li><li><a href="global.html#HFREGISTRARATTRIBUTES">HFREGISTRARATTRIBUTES</a></li><li><a href="global.html#HFREGISTRARDELEGATEROLES">HFREGISTRARDELEGATEROLES</a></li><li><a href="global.html#HFREGISTRARROLES">HFREGISTRARROLES</a></li><li><a href="global.html#HFREVOKER">HFREVOKER</a></li><li><a href="global.html#loadConfigGroup">loadConfigGroup</a></li><li><a href="global.html#loadConfigValue">loadConfigValue</a></li><li><a href="global.html#ORDERER">ORDERER</a></li><li><a href="global.html#package">package</a></li><li><a href="global.html#PEER">PEER</a></li><li><a href="global.html#toEnvelope">toEnvelope</a></li><li><a href="global.html#USER">USER</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Fri Dec 13 2019 16:08:51 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

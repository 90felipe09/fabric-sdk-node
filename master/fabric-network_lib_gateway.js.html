<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: fabric-network/lib/gateway.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: fabric-network/lib/gateway.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Copyright 2018 IBM All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
'use strict';
const Client = require('fabric-client');
const Network = require('./network');
const EventStrategies = require('fabric-network/lib/impl/event/defaulteventhandlerstrategies');
const QueryStrategies = require('fabric-network/lib/impl/query/defaultqueryhandlerstrategies');
const EventHubSelectionStrategies = require('fabric-network/lib/impl/event/defaulteventhubselectionstrategies');
const CheckpointFactories = require('fabric-network/lib/impl/event/checkpointfactories');
const logger = require('./logger').getLogger('Gateway');
/**
 * @typedef {Object} Gateway~GatewayOptions
 * @memberof module:fabric-network
 * @property {module:fabric-network.Wallet} wallet The identity wallet implementation for use with this Gateway instance.
 * @property {string} identity The identity in the wallet for all interactions on this Gateway instance.
 * @property {string} [clientTlsIdentity] The identity in the wallet to use as the client TLS identity.
 * @property {module:fabric-network.Gateway~DefaultEventHandlerOptions} [eventHandlerOptions] Options for the inbuilt default
 * event handler capability.
 * @property {module:fabric-network.Gateway~DefaultQueryHandlerOptions} [queryHandlerOptions] Options for the inbuilt
 * default query handler capability.
 * @property {module:fabric-network.Gateway~DiscoveryOptions} [discovery] Discovery options.
 * @property {module:fabric-network.Gateway~DefaultEventHubSelectionOptions} [eventHubSelectionOptions] Event hub selection options.
 * @property {module:fabric-network.Network~CheckpointerFactory} [checkpointer] Event hub selection options.
 */
/**
 * @typedef {Object} Gateway~DefaultEventHandlerOptions
 * @memberof module:fabric-network
 * @property {number} [commitTimeout = 300] The timeout period in seconds to wait for commit notification to
 * complete.
 * @property {?module:fabric-network.Gateway~TxEventHandlerFactory} [strategy=MSPID_SCOPE_ALLFORTX] Event handling strategy to identify
 * successful transaction commits. A null value indicates that no event handling is desired. The default is
 * [MSPID_SCOPE_ALLFORTX]{@link module:fabric-network.DefaultEventHandlerStrategies}.
 */
/**
 * @typedef {Function} Gateway~TxEventHandlerFactory
 * @memberof module:fabric-network
 * @param {Transaction} transaction The transaction for which the handler should listen for commit events.
 * @param {module:fabric-network.Network} network The network on which this transaction is being submitted.
 * @returns {module:fabric-network.Gateway~TxEventHandler} A transaction event handler.
 */
/**
 * @typedef {Object} Gateway~TxEventHandler
 * @memberof module:fabric-network
 * @property {Function} startListening Async function that resolves when the handler has started listening for
 * transaction commit events. Called after the transaction proposal has been accepted and prior to submission of
 * the transaction to the orderer.
 * @property {Function} waitForEvents Async function that resolves (or rejects) when suitable transaction
 * commit events have been received. Called after submission of the transaction to the orderer.
 * @property {Function} cancelListening Cancel listening. Called if submission of the transaction to the orderer
 * fails.
 */
/**
 * @typedef {Object} Gateway~DefaultEventHubSelectionOptions
 * @memberof module:fabric-network
 * @property {?module:fabric-network.Gateway~DefaultEventHubSelectionFactory} [strategy=MSPID_SCOPE_ROUND_ROBIN] Selects the next
 * event hub in the event of a new listener being created or an event hub disconnect
 */
/**
 * @typedef {Object} Gateway~DefaultEventHubSelectionFactory
 * @memberof module:fabric-network
 * @param {module:fabric-network.Network} network The network the event hub is being selected for
 * @returns {module:fabric-network.Gateway~AbstractEventHubSelectionStrategy}
 */
/**
  * @typedef {Object} Gateway~AbstractEventHubSelectionStrategy
  * @memberof module:fabric-network
  * @property {Function} getNextPeer Function that returns the next peer in the list of available peers
  * @property {Function} updateEventHubAvailability Function that updates the availability of an event hub
  */
/**
 * @typedef {Object} Gateway~DefaultQueryHandlerOptions
 * @memberof module:fabric-network
 * @property {module:fabric-network.Gateway~QueryHandlerFactory} [strategy=MSPID_SCOPE_SINGLE] Query handling strategy
 * used to evaluate queries. The default is [MSPID_SCOPE_SINGLE]{@link module:fabric-network.DefaultQueryHandlerStrategies}.
 */
/**
 * @typedef {Function} Gateway~QueryHandlerFactory
 * @memberof module:fabric-network
 * @param {module:fabric-network.Network} network The network on which queries are being evaluated.
 * @returns {module:fabric-network.Gateway~QueryHandler} A query handler.
 */
/**
 * @typedef {Object} Gateway~QueryHandler
 * @memberof module:fabric-network
 * @property {Function} evaluate Async function that takes a [Query]{@link module:fabric-network.Query} and resolves
 * with the result of the query evaluation.
 */
/**
 * @typedef {Object} Gateway~DiscoveryOptions
 * @memberof module:fabric-network
 * @property {boolean} [enabled=true] True if discovery should be used; otherwise false.
 * @property {boolean} [asLocalhost=true] Convert discovered host addresses to be 'localhost'. Will be needed when
 * running a docker composed fabric network on the local system; otherwise should be disabled.
 */
/**
 * The gateway peer provides the connection point for an application to access the Fabric network.  It is instantiated using
 * the default constructor.
 * It can then be connected to a fabric network using the [connect]{@link #connect} method by passing either a common connection profile definition
 * or an existing {@link Client} object.
 * Once connected, it can then access individual Network instances (channels) using the [getNetwork]{@link #getNetwork} method
 * which in turn can access the [smart contracts]{@link Contract} installed on a network and
 * [submit transactions]{@link Contract#submitTransaction} to the ledger.
 * @memberof module:fabric-network
 */
class Gateway {
    static _mergeOptions(defaultOptions, suppliedOptions) {
        for (const prop in suppliedOptions) {
            if (typeof suppliedOptions[prop] === 'object' &amp;&amp; suppliedOptions[prop] !== null) {
                if (defaultOptions[prop] === undefined) {
                    defaultOptions[prop] = suppliedOptions[prop];
                }
                else {
                    Gateway._mergeOptions(defaultOptions[prop], suppliedOptions[prop]);
                }
            }
            else {
                defaultOptions[prop] = suppliedOptions[prop];
            }
        }
    }
    constructor() {
        logger.debug('in Gateway constructor');
        this.client = null;
        this.wallet = null;
        this.networks = new Map();
        // default options
        this.options = {
            queryHandlerOptions: {
                strategy: QueryStrategies.MSPID_SCOPE_SINGLE
            },
            eventHandlerOptions: {
                commitTimeout: 300,
                strategy: EventStrategies.MSPID_SCOPE_ALLFORTX
            },
            discovery: {
                enabled: Client.getConfigSetting('initialize-with-discovery', true)
            },
            checkpointer: {
                factory: CheckpointFactories.FILE_SYSTEM_CHECKPOINTER,
                options: {}
            },
            eventHubSelectionOptions: {
                strategy: EventHubSelectionStrategies.MSPID_SCOPE_ROUND_ROBIN,
            }
        };
    }
    /**
     * Connect to the Gateway with a connection profile or a prebuilt Client instance.
     * @async
     * @param {(string|object|Client)} config The configuration for this Gateway which can be:
     * &lt;ul>
     *   &lt;li>A fully qualified common connection profile file path (String)&lt;/li>
     *   &lt;li>A common connection profile JSON (Object)&lt;/li>
     *   &lt;li>A pre-configured client instance&lt;/li>
     * &lt;/ul>
     * @param {module:fabric-network.Gateway~GatewayOptions} options specific options for creating this Gateway instance
     * @example
     * const gateway = new Gateway();
     * const wallet = new FileSystemWallet('./WALLETS/wallet');
     * const ccpFile = fs.readFileSync('./network.json');
     * const ccp = JSON.parse(ccpFile.toString());
     * await gateway.connect(ccp, {
     *   identity: 'admin',
     *   wallet: wallet
     * });
     */
    async connect(config, options) {
        const method = 'connect';
        logger.debug('in %s', method);
        if (!options || !options.wallet) {
            logger.error('%s - A wallet must be assigned to a Gateway instance', method);
            throw new Error('A wallet must be assigned to a Gateway instance');
        }
        Gateway._mergeOptions(this.options, options);
        logger.debug('connection options: %j', options);
        if (!(config &amp;&amp; config.constructor &amp;&amp; config.constructor.name === 'Client')) {
            // still use a ccp for the discovery peer and ca information
            logger.debug('%s - loading client from ccp', method);
            this.client = await Client.loadFromConfig(config);
        }
        else {
            // initialize from an existing Client object instance
            logger.debug('%s - using existing client object', method);
            this.client = config;
        }
        // setup an initial identity for the Gateway
        if (options.identity) {
            logger.debug('%s - setting identity', method);
            const identity = await options.wallet.get(options.identity);
            const provider = options.wallet.getProviderRegistry().getProvider(identity.type);
            await provider.setUserContext(this.client, identity, options.identity);
        }
        if (options.clientTlsIdentity) {
            const tlsIdentity = await options.wallet.get(options.clientTlsIdentity);
            this.client.setTlsClientCertAndKey(tlsIdentity.credentials.certificate, tlsIdentity.credentials.privateKey);
        }
        if (options.tlsInfo &amp;&amp; !options.clientTlsIdentity) {
            this.client.setTlsClientCertAndKey(options.tlsInfo.certificate, options.tlsInfo.key);
        }
    }
    /**
     * Get the underlying Client object instance
     *
     * @returns {Client} The underlying client instance
     */
    getClient() {
        logger.debug('in getClient');
        return this.client;
    }
    /**
     * Returns the set of options associated with the Gateway connection
     * @returns {module:fabric-network.Gateway~GatewayOptions} The Gateway connection options
     */
    getOptions() {
        logger.debug('in getOptions');
        return this.options;
    }
    /**
     * Clean up and disconnect this Gateway connection in preparation for it to be discarded and garbage collected
     */
    disconnect() {
        logger.debug('in disconnect');
        for (const network of this.networks.values()) {
            network._dispose();
        }
        this.networks.clear();
    }
    /**
     * Returns an object representing a network
     * @param {string} networkName The name of the network (channel name)
     * @returns {module:fabric-network.Network}
     */
    async getNetwork(networkName) {
        logger.debug('in getNetwork');
        const existingNetwork = this.networks.get(networkName);
        if (existingNetwork) {
            return existingNetwork;
        }
        logger.debug('getNetwork: create network object and initialize');
        let channel = this.client.getChannel(networkName, false);
        if (channel === null) {
            // not found in the in-memory cache or the CCP
            channel = this.client.newChannel(networkName);
        }
        const newNetwork = new Network(this, channel);
        await newNetwork._initialize(this.options.discovery);
        this.networks.set(networkName, newNetwork);
        return newNetwork;
    }
}
module.exports = Gateway;
//# sourceMappingURL=gateway.js.map</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-fabric-network.html">fabric-network</a></li></ul><h3>Classes</h3><ul><li><a href="AffiliationService.html">AffiliationService</a></li><li><a href="BasePackager.html">BasePackager</a></li><li><a href="BasicCommitHandler.html">BasicCommitHandler</a></li><li><a href="BlockDecoder.html">BlockDecoder</a></li><li><a href="CertificateAuthority.html">CertificateAuthority</a></li><li><a href="Chaincode.html">Chaincode</a></li><li><a href="ChaincodeRegistration.html">ChaincodeRegistration</a></li><li><a href="Channel.html">Channel</a></li><li><a href="ChannelEventHub.html">ChannelEventHub</a></li><li><a href="ChannelPeer.html">ChannelPeer</a></li><li><a href="Client.html">Client</a></li><li><a href="CommitHandler.html">CommitHandler</a></li><li><a href="DiscoveryEndorsementHandler.html">DiscoveryEndorsementHandler</a></li><li><a href="EndorsementHandler.html">EndorsementHandler</a></li><li><a href="EndorsementPolicy.html">EndorsementPolicy</a></li><li><a href="Endpoint.html">Endpoint</a></li><li><a href="event_hub_number.html">event_hub_number</a></li><li><a href="FabricCAClient.html">FabricCAClient</a></li><li><a href="FabricCAServices.html">FabricCAServices</a></li><li><a href="IdentityService.html">IdentityService</a></li><li><a href="module-fabric-network.AbstractEventHubSelectionStrategy.html">AbstractEventHubSelectionStrategy</a></li><li><a href="module-fabric-network.AbstractEventListener.html">AbstractEventListener</a></li><li><a href="module-fabric-network.BaseCheckpointer.html">BaseCheckpointer</a></li><li><a href="module-fabric-network.CommitEventListener.html">CommitEventListener</a></li><li><a href="module-fabric-network.Contract.html">Contract</a></li><li><a href="module-fabric-network.ContractEventListener.html">ContractEventListener</a></li><li><a href="module-fabric-network.EventHubDisconnectError.html">EventHubDisconnectError</a></li><li><a href="module-fabric-network.EventHubManager.html">EventHubManager</a></li><li><a href="module-fabric-network.FabricError.html">FabricError</a></li><li><a href="module-fabric-network.FileSystemCheckpointer.html">FileSystemCheckpointer</a></li><li><a href="module-fabric-network.Gateway.html">Gateway</a></li><li><a href="module-fabric-network.HsmX509Provider.html">HsmX509Provider</a></li><li><a href="module-fabric-network.IdentityProviderRegistry.html">IdentityProviderRegistry</a></li><li><a href="module-fabric-network.Network.html">Network</a></li><li><a href="module-fabric-network.Query.html">Query</a></li><li><a href="module-fabric-network.RoundRobinEventHubSelectionStrategy.html">RoundRobinEventHubSelectionStrategy</a></li><li><a href="module-fabric-network.TimeoutError.html">TimeoutError</a></li><li><a href="module-fabric-network.Transaction.html">Transaction</a></li><li><a href="module-fabric-network.Wallet.html">Wallet</a></li><li><a href="module-fabric-network.Wallets.html">Wallets</a></li><li><a href="MSP.html">MSP</a></li><li><a href="MSPManager.html">MSPManager</a></li><li><a href="NetworkConfig_1_0.html">NetworkConfig_1_0</a></li><li><a href="Orderer.html">Orderer</a></li><li><a href="Organization.html">Organization</a></li><li><a href="Peer.html">Peer</a></li><li><a href="Remote.html">Remote</a></li><li><a href="TransactionID.html">TransactionID</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-fabric-network.WalletStore.html">WalletStore</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-app-dev-env-setup.html">Setting up the Application Developer's Environment</a></li><li><a href="tutorial-chaincode-lifecycle.html">fabric-client: How to install and start your chaincode</a></li><li><a href="tutorial-channel-create.html">fabric-client: How to create a Hyperledger Fabric channel</a></li><li><a href="tutorial-channel-events.html">fabric-client: How to use the channel-based event service</a></li><li><a href="tutorial-discovery.html">fabric-client: How to use the discovery service</a></li><li><a href="tutorial-event-checkpointer.html">fabric-network: How to replay missed events</a></li><li><a href="tutorial-event-hub-management.html">fabric-network: How to automatically select and reconnect to event hubs</a></li><li><a href="tutorial-grpc-settings.html">fabric-client: How to set gRPC settings</a></li><li><a href="tutorial-handlers.html">fabric-client: How to use the endorsement and commit handlers</a></li><li><a href="tutorial-listening-to-events.html">fabric-network: How to listen to events</a></li><li><a href="tutorial-logging.html">fabric-client: How to use logging</a></li><li><a href="tutorial-metadata-chaincode.html">fabric-client: How to add CouchDB indexes during chaincode installation</a></li><li><a href="tutorial-mutual-tls.html">fabric-client: How to configure mutual TLS</a></li><li><a href="tutorial-network-config.html">fabric-client: How to use a common connection profile</a></li><li><a href="tutorial-private-data.html">How to use private data</a></li><li><a href="tutorial-query-peers.html">fabric-network: How to select peers for evaluating transactions (queries)</a></li><li><a href="tutorial-sign-transaction-offline.html">Working with an offline private key</a></li><li><a href="tutorial-transaction-commit-events.html">fabric-network: How to wait for transactions to be committed to the ledger</a></li><li><a href="tutorial-wallet.html">fabric-network: Using wallets to manage identities</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CLIENT">CLIENT</a></li><li><a href="global.html#finalPackage">finalPackage</a></li><li><a href="global.html#HFAFFILIATIONMGR">HFAFFILIATIONMGR</a></li><li><a href="global.html#HFGENCRL">HFGENCRL</a></li><li><a href="global.html#HFINTERMEDIATECA">HFINTERMEDIATECA</a></li><li><a href="global.html#HFREGISTRARATTRIBUTES">HFREGISTRARATTRIBUTES</a></li><li><a href="global.html#HFREGISTRARDELEGATEROLES">HFREGISTRARDELEGATEROLES</a></li><li><a href="global.html#HFREGISTRARROLES">HFREGISTRARROLES</a></li><li><a href="global.html#HFREVOKER">HFREVOKER</a></li><li><a href="global.html#loadConfigGroup">loadConfigGroup</a></li><li><a href="global.html#loadConfigValue">loadConfigValue</a></li><li><a href="global.html#ORDERER">ORDERER</a></li><li><a href="global.html#package">package</a></li><li><a href="global.html#PEER">PEER</a></li><li><a href="global.html#toEnvelope">toEnvelope</a></li><li><a href="global.html#USER">USER</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Thu Dec 19 2019 11:44:33 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

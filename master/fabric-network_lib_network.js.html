<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: fabric-network/lib/network.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: fabric-network/lib/network.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Copyright 2018 IBM All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
'use strict';
const FabricConstants = require('fabric-client/lib/Constants');
const Contract = require('./contract');
const EventHubManager = require('fabric-network/lib/impl/event/eventhubmanager');
const BlockEventListener = require('fabric-network/lib/impl/event/blockeventlistener');
const CommitEventListener = require('fabric-network/lib/impl/event/commiteventlistener');
const logger = require('./logger').getLogger('Network');
const util = require('util');
/**
 * @typedef {Object} Network~EventListenerOptions
 * @memberof module:fabric-network
 * @property {Object} checkpointer The checkpointer factory and options
 * @property {module:fabric-network.Network~CheckpointerFactory} checkpointer.factory The checkpointer factory
 * @property {Object} [checkpointer.options] The checkpoint configuration options
 * @property {boolean} [replay=false] event replay and checkpointing on listener
 * @property {boolean} [filtered=false] use receive filtered block events or not
 * @property {boolean} [unregister=false] unregisters the listener as soon as a single event is received
 * @property {number} [startBlock] the first block to play events from
 * @property {number} [endBlock] the final block to play events from
 * @property {boolean} [asArray] will deliver all of the events in a block to the callback
 * @property {number} [eventHubConnectWait=1000] the number of milliseconds before looking for a new event hub
 * @property {number} [eventHubConnectTimeout=30000] the number of milliseconds before timing out event hub connect
 */
/**
 * @typedef {Function} Network~CheckpointerFactory
 * @memberof module:fabric-network
 * @param {String} channelName the name of the channel the checkpoint exists in
 * @param {String} listenerName the name of the listener being checkpointed
 * @param {Object} [options] Optional. Options to configure behaviour of custom checkpointers i.e.
 * Supplying database connection details
 * @returns {BaseCheckpointer}
 */
/**
 * A Network represents the set of peers in a Fabric network.
 * Applications should get a Network instance using the
 * gateway's [getNetwork]{@link module:fabric-network.Gateway#getNetwork} method.
 * @memberof module:fabric-network
 * @hideconstructor
 */
class Network {
    /*
     * Network constructor for internal use only.
     * @param {Gateway} gateway The owning gateway instance
     * @param {Channel} channel The fabric-client channel instance
     */
    constructor(gateway, channel) {
        logger.debug('in Network constructor');
        this.gateway = gateway;
        this.channel = channel;
        this.contracts = new Map();
        this.initialized = false;
        this.listeners = new Map();
    }
    /**
     * initialize the channel if it hasn't been done
     * @private
     */
    async _initializeInternalChannel(discovery) {
        logger.debug('in _initializeInternalChannel');
        // TODO: Should this work across all peers or just orgs peers ?
        // TODO: should sort peer list to the identity org initializing the channel.
        // TODO: Candidate to push to low level node-sdk.
        let ledgerPeers;
        if (discovery.enabled) {
            const client = this.gateway.getClient();
            ledgerPeers = client.getPeersForOrg();
            if (ledgerPeers.length === 0) {
                const msg = `No peers defined for MSP '${client.getMspid()}' to discover from`;
                logger.error('_initializeInternalChannel: ' + msg);
                throw new Error(msg);
            }
        }
        else {
            ledgerPeers = this.channel.getPeers().filter((cPeer) => {
                return cPeer.isInRole(FabricConstants.NetworkConfig.LEDGER_QUERY_ROLE);
            });
            if (ledgerPeers.length === 0) {
                const msg = 'No peers defined in channel that have the ledger query role';
                logger.error('_initializeInternalChannel: ' + msg);
                throw new Error(msg);
            }
        }
        let ledgerPeerIndex = 0;
        let success = false;
        while (!success) {
            try {
                const initOptions = {
                    target: ledgerPeers[ledgerPeerIndex],
                    discover: discovery.enabled
                };
                if (typeof discovery.asLocalhost !== 'undefined') {
                    initOptions.asLocalhost = discovery.asLocalhost;
                }
                await this.channel.initialize(initOptions);
                success = true;
            }
            catch (error) {
                if (ledgerPeerIndex >= ledgerPeers.length - 1) {
                    const msg = util.format('Unable to initialize channel. Attempted to contact %j Peers. Last error was %s', ledgerPeers.length, error);
                    logger.error('_initializeInternalChannel: ' + msg);
                    throw new Error(msg);
                }
                ledgerPeerIndex++;
            }
        }
    }
    /**
     * Initialize this network instance
     * @private
     */
    async _initialize(discover) {
        logger.debug('in initialize');
        if (this.initialized) {
            return;
        }
        await this._initializeInternalChannel(discover);
        this.initialized = true;
        // Must be created after channel initialization to ensure discovery has located peers
        const queryHandlerOptions = this.gateway.getOptions().queryHandlerOptions;
        this.queryHandler = queryHandlerOptions.strategy(this, queryHandlerOptions);
        this.checkpointer = this.gateway.getOptions().checkpointer;
        const eventHubSelectionOptions = this.gateway.getOptions().eventHubSelectionOptions;
        this.eventHubSelectionStrategy = eventHubSelectionOptions.strategy(this);
        this.eventHubManager = new EventHubManager(this);
    }
    /**
     * Get the underlying channel object representation of this network.
     * @returns {Channel} A channel.
     */
    getChannel() {
        return this.channel;
    }
    /**
     * Get an instance of a contract (chaincode) on the current network.
     * @param {string} chaincodeId the chaincode identifier.
     * @param {string} [name] name of the contract.
     * @returns {module:fabric-network.Contract} the contract.
     */
    getContract(chaincodeId, name = '') {
        logger.debug('in getContract');
        if (!this.initialized) {
            throw new Error('Unable to get contract as network has failed to initialize');
        }
        const key = `${chaincodeId}:${name}`;
        let contract = this.contracts.get(key);
        if (!contract) {
            contract = new Contract(this, chaincodeId, this.gateway, this.getCheckpointer(), name);
            this.contracts.set(key, contract);
        }
        return contract;
    }
    _dispose() {
        logger.debug('in _dispose');
        this.listeners.forEach(listener => listener.unregister());
        // Danger as this cached in gateway, and also async so how would
        // network._dispose() followed by network.initialize() be safe ?
        // make this private is the safest option.
        this.contracts.clear();
        this.eventHubManager.dispose();
        this.channel.close();
        this.initialized = false;
    }
    /**
     * Get the query handler for this network.
     * @private
     * @returns {object} A query handler.
     */
    getQueryHandler() {
        return this.queryHandler;
    }
    /**
     * Get the checkpoint factory
     * @private
     * @param {Object} options the event listener options
     * @returns {Function} The checkpointer factory
     */
    getCheckpointer(options) {
        if (options) {
            if (typeof options.checkpointer === 'undefined') {
                return this.checkpointer;
            }
            else if (Object.prototype.hasOwnProperty.call(options, 'checkpointer') &amp;&amp; typeof options.checkpointer.factory === 'function') {
                return options.checkpointer;
            }
            else if (options.checkpointer === false) {
                return null;
            }
        }
        return this.checkpointer;
    }
    /**
     * Get the event hub manager
     * @private
     * @returns {module:fabric-network.EventHubManager} An event hub manager
     */
    getEventHubManager() {
        return this.eventHubManager;
    }
    /**
     * Get the event hub selection strategy
     * @private
     * @returns {module:fabric-network.AbstractEventHubSelectionStrategy}
     */
    getEventHubSelectionStrategy() {
        return this.eventHubSelectionStrategy;
    }
    /**
     * Save the listener to a map in Network
     * @param {String} listenerName the name of the listener being saved
     * @param {AbstractEventListener} listener the listener to be saved
     * @private
     */
    saveListener(listenerName, listener) {
        this._checkListenerNameIsUnique(listenerName);
        this.listeners.set(listenerName, listener);
    }
    /**
     * Create a block event listener
     * @param {String} listenerName a unique name identifying the listener
     * @param {Function} callback the callback called when an event is triggered with signature (error, block)
     * @param {module:fabric-network.Network~EventListenerOptions} [options] Optional. The event listener options
     * @returns {module:fabric-network~BlockEventListener}
     * @async
     */
    async addBlockListener(listenerName, callback, options) {
        if (!options) {
            options = {};
        }
        options.replay = options.replay ? true : false;
        options.checkpointer = this.getCheckpointer(options);
        const listener = new BlockEventListener(this, listenerName, callback, options);
        this._checkListenerNameIsUnique(listener.listenerName);
        await listener.register();
        return listener;
    }
    /**
     * Create a commit event listener for this transaction.
     * @param {string} transactionId The transactionId being watched
     * @param {Function} callback - This callback will be triggered when
     *		a transaction commit event is emitted. It takes parameters
     * 		of error, transactionId, transaction status and block number
     * @param {module:fabric-network.Network~EventListenerOptions} [options] Optional. The event listener options
     * 		registrations allowing start and end block numbers.
     * @param {ChannelEventHub} [eventHub] - Optional. Used to override the event hub selection
     * @returns {module:fabric-network~CommitEventListener}
     * @async
     */
    async addCommitListener(transactionId, callback, options, eventHub) {
        if (!options) {
            options = {};
        }
        options.replay = false;
        options.checkpointer = null;
        const listener = new CommitEventListener(this, transactionId, callback, options);
        this._checkListenerNameIsUnique(listener.listenerName);
        if (eventHub) {
            listener.setEventHub(eventHub, options.fixedEventHub);
        }
        await listener.register();
        return listener;
    }
    _checkListenerNameIsUnique(listenerName) {
        if (this.listeners.has(listenerName)) {
            throw new Error(`Listener already exists with the name ${listenerName}`);
        }
    }
}
module.exports = Network;
//# sourceMappingURL=network.js.map</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-fabric-network.html">fabric-network</a></li></ul><h3>Classes</h3><ul><li><a href="AffiliationService.html">AffiliationService</a></li><li><a href="BasePackager.html">BasePackager</a></li><li><a href="BasicCommitHandler.html">BasicCommitHandler</a></li><li><a href="BlockDecoder.html">BlockDecoder</a></li><li><a href="CertificateAuthority.html">CertificateAuthority</a></li><li><a href="Chaincode.html">Chaincode</a></li><li><a href="ChaincodeRegistration.html">ChaincodeRegistration</a></li><li><a href="Channel.html">Channel</a></li><li><a href="ChannelEventHub.html">ChannelEventHub</a></li><li><a href="ChannelPeer.html">ChannelPeer</a></li><li><a href="Client.html">Client</a></li><li><a href="CommitHandler.html">CommitHandler</a></li><li><a href="DiscoveryEndorsementHandler.html">DiscoveryEndorsementHandler</a></li><li><a href="EndorsementHandler.html">EndorsementHandler</a></li><li><a href="EndorsementPolicy.html">EndorsementPolicy</a></li><li><a href="Endpoint.html">Endpoint</a></li><li><a href="event_hub_number.html">event_hub_number</a></li><li><a href="FabricCAClient.html">FabricCAClient</a></li><li><a href="FabricCAServices.html">FabricCAServices</a></li><li><a href="IdentityService.html">IdentityService</a></li><li><a href="module-fabric-network.AbstractEventHubSelectionStrategy.html">AbstractEventHubSelectionStrategy</a></li><li><a href="module-fabric-network.AbstractEventListener.html">AbstractEventListener</a></li><li><a href="module-fabric-network.BaseCheckpointer.html">BaseCheckpointer</a></li><li><a href="module-fabric-network.CommitEventListener.html">CommitEventListener</a></li><li><a href="module-fabric-network.Contract.html">Contract</a></li><li><a href="module-fabric-network.ContractEventListener.html">ContractEventListener</a></li><li><a href="module-fabric-network.EventHubDisconnectError.html">EventHubDisconnectError</a></li><li><a href="module-fabric-network.EventHubManager.html">EventHubManager</a></li><li><a href="module-fabric-network.FabricError.html">FabricError</a></li><li><a href="module-fabric-network.FileSystemCheckpointer.html">FileSystemCheckpointer</a></li><li><a href="module-fabric-network.Gateway.html">Gateway</a></li><li><a href="module-fabric-network.HsmX509Provider.html">HsmX509Provider</a></li><li><a href="module-fabric-network.IdentityProviderRegistry.html">IdentityProviderRegistry</a></li><li><a href="module-fabric-network.Network.html">Network</a></li><li><a href="module-fabric-network.Query.html">Query</a></li><li><a href="module-fabric-network.RoundRobinEventHubSelectionStrategy.html">RoundRobinEventHubSelectionStrategy</a></li><li><a href="module-fabric-network.TimeoutError.html">TimeoutError</a></li><li><a href="module-fabric-network.Transaction.html">Transaction</a></li><li><a href="module-fabric-network.Wallet.html">Wallet</a></li><li><a href="module-fabric-network.Wallets.html">Wallets</a></li><li><a href="MSP.html">MSP</a></li><li><a href="MSPManager.html">MSPManager</a></li><li><a href="NetworkConfig_1_0.html">NetworkConfig_1_0</a></li><li><a href="Orderer.html">Orderer</a></li><li><a href="Organization.html">Organization</a></li><li><a href="Peer.html">Peer</a></li><li><a href="Remote.html">Remote</a></li><li><a href="TransactionID.html">TransactionID</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-fabric-network.WalletStore.html">WalletStore</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-app-dev-env-setup.html">Setting up the Application Developer's Environment</a></li><li><a href="tutorial-chaincode-lifecycle.html">fabric-client: How to install and start your chaincode</a></li><li><a href="tutorial-channel-create.html">fabric-client: How to create a Hyperledger Fabric channel</a></li><li><a href="tutorial-channel-events.html">fabric-client: How to use the channel-based event service</a></li><li><a href="tutorial-discovery.html">fabric-client: How to use the discovery service</a></li><li><a href="tutorial-event-checkpointer.html">fabric-network: How to replay missed events</a></li><li><a href="tutorial-event-hub-management.html">fabric-network: How to automatically select and reconnect to event hubs</a></li><li><a href="tutorial-grpc-settings.html">fabric-client: How to set gRPC settings</a></li><li><a href="tutorial-handlers.html">fabric-client: How to use the endorsement and commit handlers</a></li><li><a href="tutorial-listening-to-events.html">fabric-network: How to listen to events</a></li><li><a href="tutorial-logging.html">fabric-client: How to use logging</a></li><li><a href="tutorial-metadata-chaincode.html">fabric-client: How to add CouchDB indexes during chaincode installation</a></li><li><a href="tutorial-mutual-tls.html">fabric-client: How to configure mutual TLS</a></li><li><a href="tutorial-network-config.html">fabric-client: How to use a common connection profile</a></li><li><a href="tutorial-private-data.html">How to use private data</a></li><li><a href="tutorial-query-peers.html">fabric-network: How to select peers for evaluating transactions (queries)</a></li><li><a href="tutorial-sign-transaction-offline.html">Working with an offline private key</a></li><li><a href="tutorial-transaction-commit-events.html">fabric-network: How to wait for transactions to be committed to the ledger</a></li><li><a href="tutorial-wallet.html">fabric-network: Using wallets to manage identities</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CLIENT">CLIENT</a></li><li><a href="global.html#finalPackage">finalPackage</a></li><li><a href="global.html#HFAFFILIATIONMGR">HFAFFILIATIONMGR</a></li><li><a href="global.html#HFGENCRL">HFGENCRL</a></li><li><a href="global.html#HFINTERMEDIATECA">HFINTERMEDIATECA</a></li><li><a href="global.html#HFREGISTRARATTRIBUTES">HFREGISTRARATTRIBUTES</a></li><li><a href="global.html#HFREGISTRARDELEGATEROLES">HFREGISTRARDELEGATEROLES</a></li><li><a href="global.html#HFREGISTRARROLES">HFREGISTRARROLES</a></li><li><a href="global.html#HFREVOKER">HFREVOKER</a></li><li><a href="global.html#loadConfigGroup">loadConfigGroup</a></li><li><a href="global.html#loadConfigValue">loadConfigValue</a></li><li><a href="global.html#ORDERER">ORDERER</a></li><li><a href="global.html#package">package</a></li><li><a href="global.html#PEER">PEER</a></li><li><a href="global.html#toEnvelope">toEnvelope</a></li><li><a href="global.html#USER">USER</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Mon Dec 23 2019 09:47:01 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

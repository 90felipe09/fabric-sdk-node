<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Tutorial: Working with an offline private key</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Tutorial: Working with an offline private key</h1>

    <section>

<header>
    

    <h2>Working with an offline private key</h2>
</header>

<article>
    <p>This tutorial illustrates how to work with an offline private key with the Hyperledger Fabric Node.js SDK (fabric-client and fabric-ca-client) APIs.</p>
<p>For more information on:</p>
<ul>
<li>getting started with Hyperledger Fabric see
<a href="http://hyperledger-fabric.readthedocs.io/en/latest/build_network.html">Building your first network</a>.</li>
<li>The transactional mechanics that take place during a standard asset exchange.
<a href="https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html">transacton flow in fabric</a>.</li>
<li>The Certificate Signing Request (CSR) in a PKI system.
<a href="https://en.wikipedia.org/wiki/Certificate_signing_request">CSR</a></li>
</ul>
<p>The following assumes an understanding of the Hyperledger Fabric network
(orderers and peers),
and of Node application development, including the use of the
Javascript <code>promise</code> and <code>async await</code>.</p>
<h2>Overview</h2>
<p>In most use cases the <code>fabric-client</code> will persist the user's credentials including the private key and sign transactions for the user. However some business scenarios may require higher level of privacy. What if the user wants to keep their private key secret and does not trust another system or backend server to securely store it and use it?</p>
<p>The <code>fabric-client</code> comes with the ability to sign a transaction with an offline private key. By contrast to call <code>setUserContext()</code> with the user's identity (which contains the user's private key), an alternative way is to split the <code>sign a tx</code> process out of the <code>fabric-client</code> and let the application layer choose the place to store the private key, sign the transaction and send the signed transaction back. By this approach, the <code>fabric-client</code> does not require the user's private key any more.</p>
<p>The Fabric-ca comes with the ability to enroll with a PKCS#10 standard CSR, which means the user can use an existing key pairs to generate the CSR and send this CSR to Fabric-ca to get the signed certificate. The <code>fabric-ca-client</code> also accepts a CSR at the API <code>enroll()</code>.</p>
<h2>The transaction flow for signing a transaction offline</h2>
<p>The following will show the steps to signing a transaction offline:</p>
<p>With the user's identity (cert and private key) set at the fabric client:</p>
<ol>
<li>Endorse -&gt; <code>Channel.sendTransactionProposal()</code></li>
<li>Commit -&gt; <code>Channel.sendTransaction()</code></li>
<li>ChannelEventHub -&gt; <code>ChannelEventHub.connect()</code> (if the channel-eventhub has not connected to the peers)</li>
</ol>
<p>Without the user's private key at the fabric client:</p>
<ol>
<li>Endorse:
<ol>
<li>generate an <code>unsigned transaction proposal</code> with the identity's certificate -&gt; <code>Channel.generateUnsignedProposal()</code></li>
<li>sign the <code>unsigned transaction proposal</code> with the identity's private key offline producing a <code>signed transaction proposal</code></li>
<li>send the <code>signed transaction proposal</code> to the peer(s) and get endorsement(s) -&gt; <code>Channel.sendSignedProposal()</code></li>
</ol>
</li>
<li>Commit:
<ol>
<li>generate an <code>unsigned transaction</code> with the endorsements -&gt; <code>Channel.generateUnsignedTransaction()</code></li>
<li>sign the <code>unsigned transaction</code> with the identity's private key offline producing a <code>signed transaction</code></li>
<li>send the <code>signed transaction</code> to the orderer -&gt; <code>Channel.sendSignedTransaction()</code></li>
</ol>
</li>
<li>Register Channel Event Listerner:
If the channel event hub has not connected to the peer, the channel eventhub registration needs the private key's signature too.
<ol>
<li>generate an <code>unsigned eventhub registration</code> for the ChannelEventHub -&gt; <code>ChannelEventHub.generateUnsignedRegistration()</code></li>
<li>sign the <code>unsigned eventhub registration</code> with the identity's private key offline producing a <code>signed eventhub registration</code></li>
<li>using the <code>signed eventhub registration</code> for the ChannelEventHub's registration -&gt; <code>ChannelEventHub.connect({signedEvent})</code></li>
</ol>
</li>
</ol>
<h2>How to sign a transaction by an identity's private key</h2>
<p>There might be several digital signature algorithms. If we set the user's identity at the fabric client, the fabric client would use ECDSA with algorithm 'EC' by default.</p>
<p>Here is how this works with an offline private key.</p>
<ol>
<li>
<p>first, generate an <code>unsigned transaction proposal</code> with the identity's certificate</p>
<pre class="prettyprint source lang-javascript"><code>const certPem = '&lt;PEM encoded certificate content>';
const mspId = 'Org1MSP'; // the msp Id for this org

const transactionProposal = {
    fcn: 'move',
    args: ['a', 'b', '100'],
    chaincodeId: 'mychaincodeId',
    channelId: 'mychannel',
};
const { proposal, txId } = channel.generateUnsignedProposal(transactionProposal, mspId, certPem);
// now we have the 'unsigned proposal' for this transaction
</code></pre>
</li>
<li>
<p>calculate the hash of the transaction proposal bytes.</p>
<p>A hash algorithm should be picked and calculate the hash of the transaction proposal bytes.</p>
<p>There exists multiple hash functions (such as SHA2/3). by default, the fabric client will use 'SHA2' with key size 256.</p>
<p>The user may use an alternative implementation</p>
<pre class="prettyprint source lang-javascript"><code>const proposalBytes = proposal.toBuffer(); // the proposal comes from step 1

const hashFunction = xxxx; // A hash function by the user's desire

const digest = hashFunction(proposalBytes); // calculate the hash of the proposal bytes
</code></pre>
</li>
<li>
<p>calculate the signature for this transaction proposal</p>
<p>We may have a series of choices for the signature algorithm. Including asymmetric keys (such as ECDSA or RSA), symmetric keys (such as AES).</p>
<p>By default the the fabric client will use ECDSA with algorithm 'EC'.</p>
<pre class="prettyprint source lang-javascript"><code>// This is a sample code for signing the digest from step 2 with EC.
// Different signature algorithm may have different interfaces

const elliptic = require('elliptic');
const { KEYUTIL } = require('jsrsasign');

const privateKeyPEM = '&lt;The PEM encoded private key>';
const { prvKeyHex } = KEYUTIL.getKey(privateKeyPEM); // convert the pem encoded key to hex encoded private key

const EC = elliptic.ec;
const ecdsaCurve = elliptic.curves['p256'];

const ecdsa = new EC(ecdsaCurve);
const signKey = ecdsa.keyFromPrivate(prvKeyHex, 'hex');
const sig = ecdsa.sign(Buffer.from(digest, 'hex'), signKey);

// now we have the signature, next we should send the signed transaction proposal to the peer
const signature = Buffer.from(sig.toDER());
const signedProposal = {
    signature,
    proposal_bytes: proposalBytes,
};
</code></pre>
</li>
<li>
<p>send the <code>signed transaction proposal</code> to peer(s)</p>
<pre class="prettyprint source lang-javascript"><code>
const sendSignedProposalReq = { signedProposal, targets };
const proposalResponses = await channel.sendSignedProposal(sendSignedProposalReq);
// check the proposal responses, if all good, commit the transaction
</code></pre>
</li>
<li>
<p>similar to step 1, generate an <code>unsigned transaction</code></p>
<pre class="prettyprint source lang-javascript"><code>const commitReq = {
    proposalResponses,
    proposal,
};

const commitProposal = await channel.generateUnsignedTransaction(commitReq);
</code></pre>
</li>
<li>
<p>similar to step 3, sign the <code>unsigned transaction</code> with the user's private key</p>
<pre class="prettyprint source lang-javascript"><code>const signedCommitProposal = signProposal(commitProposal);
</code></pre>
</li>
<li>
<p>commit the <code>signed transaction</code></p>
<pre class="prettyprint source lang-javascript"><code>const response = await channel.sendSignedTransaction({
    signedProposal: signedCommitProposal,
    request: commitReq,
});

// response.status should be 'SUCCESS' if the commit succeed
</code></pre>
</li>
<li>
<p>similar to step 1, generate an <code>unsigned eventhub registration</code> for the ChannelEventHub.</p>
<pre class="prettyprint source lang-javascript"><code>const unsignedEvent = eh.generateUnsignedRegistration({
    certificate: certPem,
    mspId,
});
</code></pre>
</li>
<li>
<p>similar to step 3, sign the <code>unsigned eventhub registration</code> with the user's private key</p>
<pre class="prettyprint source lang-javascript"><code>const signedProposal = signProposal(unsignedEvent);
const signedEvent = {
    signature: signedProposal.signature,
    payload: signedProposal.proposal_bytes,
};
</code></pre>
</li>
<li>
<p>register this ChannelEventHub at peer</p>
<pre class="prettyprint source lang-javascript"><code>channelEventHub.connect({signedEvent});
</code></pre>
</li>
</ol>
<p>A full test can be found at <code>fabric-sdk-node/test/integration/signTransactionOffline.js</code></p>
<h2>How to enroll with a CSR</h2>
<p>The <code>fabric-ca-client</code> provides the API <code>enroll()</code> that accepts an optional param 'CSR'.
If the params does not contains CSR, <code>fabric-ca-client</code> will first generate a key pair,
then use the user's enrollmentID as the common name to create a CSR which is signed with
the new generated private key. The response will contain the private key object if no 'CSR'
in enroll params.</p>
<p>To enroll with a CSR, first we should call <code>fabric-ca-client</code> API <code>register</code> to register
a new identity at Fabric-ca. After a successfully register, we have the <code>enrollmentID</code> and <code>enrollmentSecret</code>.</p>
<p>Then we should create the CSR. A common way is using the <code>openssl</code> command.</p>
<blockquote>
<p>Notice the CSR must contain the information &quot;common name&quot; and the &quot;common name&quot; must be
same as the &quot;enrollmentID&quot; at the register step.</p>
</blockquote>
<p>Here is an example of how to create a CSR with the key algorithm rsa and key size 2048 bits</p>
<pre class="prettyprint source"><code>openssl req -nodes -newkey rsa:2048 -keyout test.key -out test.csr
</code></pre>
<p>The <code>test.csr</code> from the above command is represented as a Base64 encoded PKCS#10.</p>
<p>Here is how we call enroll with a CSR</p>
<pre class="prettyprint source lang-javascript"><code>const fs = require('fs');
const csr = fs.readFileSync('the path to test.csr', 'utf8');
const req = {
    enrollmentID: enrollmentID,
    enrollmentSecret: enrollmentSecret,
    csr: csr,
};

const enrollment = await caService.enroll(req);

// the enrollment.certificate contains the signed certificate from Fabric-ca
</code></pre>
</article>

</section>

</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-fabric-network.html">fabric-network</a></li></ul><h3>Classes</h3><ul><li><a href="AffiliationService.html">AffiliationService</a></li><li><a href="BasePackager.html">BasePackager</a></li><li><a href="BasicCommitHandler.html">BasicCommitHandler</a></li><li><a href="BlockDecoder.html">BlockDecoder</a></li><li><a href="CertificateAuthority.html">CertificateAuthority</a></li><li><a href="Chaincode.html">Chaincode</a></li><li><a href="ChaincodeRegistration.html">ChaincodeRegistration</a></li><li><a href="Channel.html">Channel</a></li><li><a href="ChannelEventHub.html">ChannelEventHub</a></li><li><a href="ChannelPeer.html">ChannelPeer</a></li><li><a href="Client.html">Client</a></li><li><a href="CommitHandler.html">CommitHandler</a></li><li><a href="DiscoveryEndorsementHandler.html">DiscoveryEndorsementHandler</a></li><li><a href="EndorsementHandler.html">EndorsementHandler</a></li><li><a href="EndorsementPolicy.html">EndorsementPolicy</a></li><li><a href="Endpoint.html">Endpoint</a></li><li><a href="event_hub_number.html">event_hub_number</a></li><li><a href="FabricCAClient.html">FabricCAClient</a></li><li><a href="FabricCAServices.html">FabricCAServices</a></li><li><a href="IdentityService.html">IdentityService</a></li><li><a href="module-fabric-network.AbstractEventHubSelectionStrategy.html">AbstractEventHubSelectionStrategy</a></li><li><a href="module-fabric-network.AbstractEventListener.html">AbstractEventListener</a></li><li><a href="module-fabric-network.BaseCheckpointer.html">BaseCheckpointer</a></li><li><a href="module-fabric-network.CommitEventListener.html">CommitEventListener</a></li><li><a href="module-fabric-network.Contract.html">Contract</a></li><li><a href="module-fabric-network.ContractEventListener.html">ContractEventListener</a></li><li><a href="module-fabric-network.EventHubDisconnectError.html">EventHubDisconnectError</a></li><li><a href="module-fabric-network.EventHubManager.html">EventHubManager</a></li><li><a href="module-fabric-network.FabricError.html">FabricError</a></li><li><a href="module-fabric-network.FileSystemCheckpointer.html">FileSystemCheckpointer</a></li><li><a href="module-fabric-network.Gateway.html">Gateway</a></li><li><a href="module-fabric-network.HsmX509Provider.html">HsmX509Provider</a></li><li><a href="module-fabric-network.IdentityProviderRegistry.html">IdentityProviderRegistry</a></li><li><a href="module-fabric-network.Network.html">Network</a></li><li><a href="module-fabric-network.Query.html">Query</a></li><li><a href="module-fabric-network.RoundRobinEventHubSelectionStrategy.html">RoundRobinEventHubSelectionStrategy</a></li><li><a href="module-fabric-network.TimeoutError.html">TimeoutError</a></li><li><a href="module-fabric-network.Transaction.html">Transaction</a></li><li><a href="module-fabric-network.Wallet.html">Wallet</a></li><li><a href="module-fabric-network.Wallets.html">Wallets</a></li><li><a href="MSP.html">MSP</a></li><li><a href="MSPManager.html">MSPManager</a></li><li><a href="NetworkConfig_1_0.html">NetworkConfig_1_0</a></li><li><a href="Orderer.html">Orderer</a></li><li><a href="Organization.html">Organization</a></li><li><a href="Peer.html">Peer</a></li><li><a href="Remote.html">Remote</a></li><li><a href="TransactionID.html">TransactionID</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-fabric-network.WalletStore.html">WalletStore</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-app-dev-env-setup.html">Setting up the Application Developer's Environment</a></li><li><a href="tutorial-chaincode-lifecycle.html">fabric-client: How to install and start your chaincode</a></li><li><a href="tutorial-channel-create.html">fabric-client: How to create a Hyperledger Fabric channel</a></li><li><a href="tutorial-channel-events.html">fabric-client: How to use the channel-based event service</a></li><li><a href="tutorial-discovery.html">fabric-client: How to use the discovery service</a></li><li><a href="tutorial-event-checkpointer.html">fabric-network: How to replay missed events</a></li><li><a href="tutorial-event-hub-management.html">fabric-network: How to automatically select and reconnect to event hubs</a></li><li><a href="tutorial-grpc-settings.html">fabric-client: How to set gRPC settings</a></li><li><a href="tutorial-handlers.html">fabric-client: How to use the endorsement and commit handlers</a></li><li><a href="tutorial-listening-to-events.html">fabric-network: How to listen to events</a></li><li><a href="tutorial-logging.html">fabric-client: How to use logging</a></li><li><a href="tutorial-metadata-chaincode.html">fabric-client: How to add CouchDB indexes during chaincode installation</a></li><li><a href="tutorial-mutual-tls.html">fabric-client: How to configure mutual TLS</a></li><li><a href="tutorial-network-config.html">fabric-client: How to use a common connection profile</a></li><li><a href="tutorial-private-data.html">How to use private data</a></li><li><a href="tutorial-query-peers.html">fabric-network: How to select peers for evaluating transactions (queries)</a></li><li><a href="tutorial-sign-transaction-offline.html">Working with an offline private key</a></li><li><a href="tutorial-transaction-commit-events.html">fabric-network: How to wait for transactions to be committed to the ledger</a></li><li><a href="tutorial-wallet.html">fabric-network: Using wallets to manage identities</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CLIENT">CLIENT</a></li><li><a href="global.html#finalPackage">finalPackage</a></li><li><a href="global.html#HFAFFILIATIONMGR">HFAFFILIATIONMGR</a></li><li><a href="global.html#HFGENCRL">HFGENCRL</a></li><li><a href="global.html#HFINTERMEDIATECA">HFINTERMEDIATECA</a></li><li><a href="global.html#HFREGISTRARATTRIBUTES">HFREGISTRARATTRIBUTES</a></li><li><a href="global.html#HFREGISTRARDELEGATEROLES">HFREGISTRARDELEGATEROLES</a></li><li><a href="global.html#HFREGISTRARROLES">HFREGISTRARROLES</a></li><li><a href="global.html#HFREVOKER">HFREVOKER</a></li><li><a href="global.html#loadConfigGroup">loadConfigGroup</a></li><li><a href="global.html#loadConfigValue">loadConfigValue</a></li><li><a href="global.html#ORDERER">ORDERER</a></li><li><a href="global.html#package">package</a></li><li><a href="global.html#PEER">PEER</a></li><li><a href="global.html#toEnvelope">toEnvelope</a></li><li><a href="global.html#USER">USER</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Thu Dec 19 2019 11:41:35 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: fabric-client/lib/client-utils.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: fabric-client/lib/client-utils.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Copyright 2018 IBM All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

'use strict';

const settle = require('promise-settle');
const util = require('util');
const {Utils: utils} = require('fabric-common');
const logger = utils.getLogger('client-utils.js');

const fabprotos = require('fabric-protos');

/*
 * This function will build the proposal
 */
module.exports.buildProposal = (chaincodeSpec, header, transientMap) => {
	// construct the ChaincodeInvocationSpec
	const cciSpec = new fabprotos.protos.ChaincodeInvocationSpec();
	cciSpec.setChaincodeSpec(chaincodeSpec);

	const cc_payload = new fabprotos.protos.ChaincodeProposalPayload();
	cc_payload.setInput(cciSpec.toBuffer());

	if (typeof transientMap === 'object') {
		logger.debug('buildProposal - adding in transientMap %s', util.inspect(transientMap));
		cc_payload.setTransientMap(transientMap);
	} else {
		logger.debug('buildProposal - not adding a transientMap');
	}

	// proposal -- will switch to building the proposal once the signProposal is used
	const proposal = new fabprotos.protos.Proposal();
	proposal.setHeader(header.toBuffer());
	proposal.setPayload(cc_payload.toBuffer()); // chaincode proposal payload

	return proposal;
};

/*
 * This function will return one Promise when sending a proposal to many peers
 */
module.exports.sendPeersProposal = async (peers, proposal, timeout) => {
	let targets = peers;
	if (!Array.isArray(peers)) {
		targets = [peers];
	}
	// create array of promises mapping peers array to peer parameter
	// settle all the promises and return array of responses
	const promises = targets.map(async (peer) => {
		return peer.sendProposal(proposal, timeout);
	});
	const responses = [];
	const results = await settle(promises);
	results.forEach((result) => {
		if (result.isFulfilled()) {
			logger.debug(`sendPeersProposal - Promise is fulfilled: ${result.value()}`);
			responses.push(result.value());
		} else {
			logger.debug(`sendPeersProposal - Promise is rejected: ${result.reason()}`);
			responses.push(result.reason());
		}
	});
	return responses;
};

/*
 * This function will sign the proposal
 */
module.exports.signProposal = (signingIdentity, proposal) => {
	const proposal_bytes = proposal.toBuffer();
	// sign the proposal
	const signature = Buffer.from(signingIdentity.sign(proposal_bytes));

	// build manually for now
	return {
		signature,
		proposal_bytes
	};
};
/**
 * convert proposal.proto:SignedProposal to be common.proto:Envelope
 * @param signature
 * @param proposal_bytes
 */
module.exports.toEnvelope = ({signature, proposal_bytes}) => ({signature, payload: proposal_bytes});


module.exports.buildSignedProposal = (request, channelId, client_context) => {
	const method = 'buildSignedProposal';
	logger.debug('%s - start', method);

	const args = [];
	args.push(Buffer.from(request.fcn ? request.fcn : 'invoke', 'utf8'));
	logger.debug('%s - adding function arg:%s', method, request.fcn ? request.fcn : 'invoke');

	for (let i = 0; i &lt; request.args.length; i++) {
		logger.debug('%s - adding arg', method);
		args.push(Buffer.from(request.args[i], 'utf8'));
	}
	// special case to support the bytes argument of the query by hash
	if (request.argbytes) {
		logger.debug('%s - adding the argument :: argbytes', method);
		args.push(request.argbytes);
	} else {
		logger.debug('%s - not adding the argument :: argbytes', method);
	}

	logger.debug('%s - chaincode ID:%s', method, request.chaincodeId);
	const chaincodeSpec = new fabprotos.protos.ChaincodeSpec();
	chaincodeSpec.setType(fabprotos.protos.ChaincodeSpec.Type.GOLANG);
	const chaincode_id = new fabprotos.protos.ChaincodeID();
	chaincode_id.setName(request.chaincodeId);
	chaincodeSpec.setChaincodeId(chaincode_id);
	const input = new fabprotos.protos.ChaincodeInput();
	input.setArgs(args);
	if (request.is_init) {
		input.setIsInit(true);
	}
	chaincodeSpec.setInput(input);

	let signer = null;
	if (request.signer) {
		signer = request.signer;
	} else {
		signer = client_context._getSigningIdentity(request.txId.isAdmin());
	}

	const channelHeader = module.exports.buildChannelHeader(
		fabprotos.common.HeaderType.ENDORSER_TRANSACTION,
		channelId,
		request.txId.getTransactionID(),
		null,
		request.chaincodeId,
		module.exports.buildCurrentTimestamp(),
		client_context.getClientCertHash()
	);

	const header = module.exports.buildHeader(signer, channelHeader, request.txId.getNonce());
	const proposal = module.exports.buildProposal(chaincodeSpec, header, request.transientMap);
	const signed_proposal = module.exports.signProposal(signer, proposal);

	return {signed: signed_proposal, source: proposal};
};

/*
 * This function will build a common channel header
 */
module.exports.buildChannelHeader = (type, channel_id, tx_id, epoch, chaincode_id, time_stamp, client_cert_hash) => {
	logger.debug(
		'buildChannelHeader - type %s channel_id %s tx_id %d epoch %s chaincode_id %s',
		type, channel_id, tx_id, epoch, chaincode_id);
	const channelHeader = new fabprotos.common.ChannelHeader();
	channelHeader.setType(type); // int32
	channelHeader.setVersion(1); // int32
	if (!time_stamp) {
		time_stamp = module.exports.buildCurrentTimestamp();
	}
	channelHeader.setChannelId(channel_id); // string
	channelHeader.setTxId(tx_id.toString()); // string
	if (epoch) {
		channelHeader.setEpoch(epoch); // uint64
	}
	if (chaincode_id) {
		const chaincodeID = new fabprotos.protos.ChaincodeID();
		chaincodeID.setName(chaincode_id);

		const headerExt = new fabprotos.protos.ChaincodeHeaderExtension();
		headerExt.setChaincodeId(chaincodeID);

		channelHeader.setExtension(headerExt.toBuffer());
	}
	if (time_stamp) {
		channelHeader.setTimestamp(time_stamp); // google.protobuf.Timestamp
	}
	if (client_cert_hash) {
		channelHeader.setTlsCertHash(client_cert_hash);
	}
	return channelHeader;
};

/*
 * This function will build the common header
 */
module.exports.buildHeader = (creator, channelHeader, nonce) => {
	const signatureHeader = new fabprotos.common.SignatureHeader();
	signatureHeader.setCreator(creator.serialize());
	signatureHeader.setNonce(nonce);

	const header = new fabprotos.common.Header();
	header.setSignatureHeader(signatureHeader.toBuffer());
	header.setChannelHeader(channelHeader.toBuffer());

	return header;
};

module.exports.checkProposalRequest = (request, all) => {
	let errorMsg = null;

	if (request) {
		if (!request.chaincodeId) {
			errorMsg = 'Missing "chaincodeId" parameter in the proposal request';
		} else if (!request.txId &amp;&amp; all) {
			errorMsg = 'Missing "txId" parameter in the proposal request';
		}
	} else {
		errorMsg = 'Missing input request object on the proposal request';
	}
	return errorMsg;
};

module.exports.checkInstallRequest = (request) => {
	let errorMsg = null;

	if (request) {
		if (!request.chaincodeVersion) {
			errorMsg = 'Missing "chaincodeVersion" parameter in the proposal request';
		}
	} else {
		errorMsg = 'Missing input request object on the proposal request';
	}
	return errorMsg;
};

module.exports.translateCCType = (type) => {
	const chaincodeType = type ? type.toLowerCase() : 'golang';

	const map = {
		golang: fabprotos.protos.ChaincodeSpec.Type.GOLANG,
		car: fabprotos.protos.ChaincodeSpec.Type.CAR,
		java: fabprotos.protos.ChaincodeSpec.Type.JAVA,
		node: fabprotos.protos.ChaincodeSpec.Type.NODE
	};
	const value = map[chaincodeType];

	return value;
};

module.exports.ccTypeToString = (ccType) => {
	const map = {};
	map[fabprotos.protos.ChaincodeSpec.Type.GOLANG] = 'golang';
	map[fabprotos.protos.ChaincodeSpec.Type.CAR] = 'car';
	map[fabprotos.protos.ChaincodeSpec.Type.JAVA] = 'java';
	map[fabprotos.protos.ChaincodeSpec.Type.NODE] = 'node';
	const value = map[ccType];

	return value;
};

/* TODO move it to fabric-proto
 * This function will create a timestamp from the current time
 */
module.exports.buildCurrentTimestamp = () => {
	const now = new Date();
	const timestamp = new fabprotos.google.protobuf.Timestamp();
	timestamp.setSeconds(now.getTime() / 1000);
	timestamp.setNanos((now.getTime() % 1000) * 1000000);
	return timestamp;
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-fabric-network.html">fabric-network</a></li></ul><h3>Classes</h3><ul><li><a href="AffiliationService.html">AffiliationService</a></li><li><a href="BasePackager.html">BasePackager</a></li><li><a href="BasicCommitHandler.html">BasicCommitHandler</a></li><li><a href="BlockDecoder.html">BlockDecoder</a></li><li><a href="CertificateAuthority.html">CertificateAuthority</a></li><li><a href="Chaincode.html">Chaincode</a></li><li><a href="ChaincodeRegistration.html">ChaincodeRegistration</a></li><li><a href="Channel.html">Channel</a></li><li><a href="ChannelEventHub.html">ChannelEventHub</a></li><li><a href="ChannelPeer.html">ChannelPeer</a></li><li><a href="Client.html">Client</a></li><li><a href="CommitHandler.html">CommitHandler</a></li><li><a href="DiscoveryEndorsementHandler.html">DiscoveryEndorsementHandler</a></li><li><a href="EndorsementHandler.html">EndorsementHandler</a></li><li><a href="EndorsementPolicy.html">EndorsementPolicy</a></li><li><a href="Endpoint.html">Endpoint</a></li><li><a href="event_hub_number.html">event_hub_number</a></li><li><a href="FabricCAClient.html">FabricCAClient</a></li><li><a href="FabricCAServices.html">FabricCAServices</a></li><li><a href="IdentityService.html">IdentityService</a></li><li><a href="module-fabric-network.AbstractEventHubSelectionStrategy.html">AbstractEventHubSelectionStrategy</a></li><li><a href="module-fabric-network.AbstractEventListener.html">AbstractEventListener</a></li><li><a href="module-fabric-network.BaseCheckpointer.html">BaseCheckpointer</a></li><li><a href="module-fabric-network.CommitEventListener.html">CommitEventListener</a></li><li><a href="module-fabric-network.Contract.html">Contract</a></li><li><a href="module-fabric-network.ContractEventListener.html">ContractEventListener</a></li><li><a href="module-fabric-network.EventHubDisconnectError.html">EventHubDisconnectError</a></li><li><a href="module-fabric-network.EventHubManager.html">EventHubManager</a></li><li><a href="module-fabric-network.FabricError.html">FabricError</a></li><li><a href="module-fabric-network.FileSystemCheckpointer.html">FileSystemCheckpointer</a></li><li><a href="module-fabric-network.Gateway.html">Gateway</a></li><li><a href="module-fabric-network.HsmX509Provider.html">HsmX509Provider</a></li><li><a href="module-fabric-network.IdentityProviderRegistry.html">IdentityProviderRegistry</a></li><li><a href="module-fabric-network.Network.html">Network</a></li><li><a href="module-fabric-network.Query.html">Query</a></li><li><a href="module-fabric-network.RoundRobinEventHubSelectionStrategy.html">RoundRobinEventHubSelectionStrategy</a></li><li><a href="module-fabric-network.TimeoutError.html">TimeoutError</a></li><li><a href="module-fabric-network.Transaction.html">Transaction</a></li><li><a href="module-fabric-network.Wallet.html">Wallet</a></li><li><a href="module-fabric-network.Wallets.html">Wallets</a></li><li><a href="MSP.html">MSP</a></li><li><a href="MSPManager.html">MSPManager</a></li><li><a href="NetworkConfig_1_0.html">NetworkConfig_1_0</a></li><li><a href="Orderer.html">Orderer</a></li><li><a href="Organization.html">Organization</a></li><li><a href="Peer.html">Peer</a></li><li><a href="Remote.html">Remote</a></li><li><a href="TransactionID.html">TransactionID</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-fabric-network.WalletStore.html">WalletStore</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-app-dev-env-setup.html">Setting up the Application Developer's Environment</a></li><li><a href="tutorial-chaincode-lifecycle.html">fabric-client: How to install and start your chaincode</a></li><li><a href="tutorial-channel-create.html">fabric-client: How to create a Hyperledger Fabric channel</a></li><li><a href="tutorial-channel-events.html">fabric-client: How to use the channel-based event service</a></li><li><a href="tutorial-discovery.html">fabric-client: How to use the discovery service</a></li><li><a href="tutorial-event-checkpointer.html">fabric-network: How to replay missed events</a></li><li><a href="tutorial-event-hub-management.html">fabric-network: How to automatically select and reconnect to event hubs</a></li><li><a href="tutorial-grpc-settings.html">fabric-client: How to set gRPC settings</a></li><li><a href="tutorial-handlers.html">fabric-client: How to use the endorsement and commit handlers</a></li><li><a href="tutorial-listening-to-events.html">fabric-network: How to listen to events</a></li><li><a href="tutorial-logging.html">fabric-client: How to use logging</a></li><li><a href="tutorial-metadata-chaincode.html">fabric-client: How to add CouchDB indexes during chaincode installation</a></li><li><a href="tutorial-mutual-tls.html">fabric-client: How to configure mutual TLS</a></li><li><a href="tutorial-network-config.html">fabric-client: How to use a common connection profile</a></li><li><a href="tutorial-private-data.html">How to use private data</a></li><li><a href="tutorial-query-peers.html">fabric-network: How to select peers for evaluating transactions (queries)</a></li><li><a href="tutorial-sign-transaction-offline.html">Working with an offline private key</a></li><li><a href="tutorial-transaction-commit-events.html">fabric-network: How to wait for transactions to be committed to the ledger</a></li><li><a href="tutorial-wallet.html">fabric-network: Using wallets to manage identities</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CLIENT">CLIENT</a></li><li><a href="global.html#finalPackage">finalPackage</a></li><li><a href="global.html#HFAFFILIATIONMGR">HFAFFILIATIONMGR</a></li><li><a href="global.html#HFGENCRL">HFGENCRL</a></li><li><a href="global.html#HFINTERMEDIATECA">HFINTERMEDIATECA</a></li><li><a href="global.html#HFREGISTRARATTRIBUTES">HFREGISTRARATTRIBUTES</a></li><li><a href="global.html#HFREGISTRARDELEGATEROLES">HFREGISTRARDELEGATEROLES</a></li><li><a href="global.html#HFREGISTRARROLES">HFREGISTRARROLES</a></li><li><a href="global.html#HFREVOKER">HFREVOKER</a></li><li><a href="global.html#loadConfigGroup">loadConfigGroup</a></li><li><a href="global.html#loadConfigValue">loadConfigValue</a></li><li><a href="global.html#ORDERER">ORDERER</a></li><li><a href="global.html#package">package</a></li><li><a href="global.html#PEER">PEER</a></li><li><a href="global.html#toEnvelope">toEnvelope</a></li><li><a href="global.html#USER">USER</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Thu Dec 19 2019 11:41:34 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

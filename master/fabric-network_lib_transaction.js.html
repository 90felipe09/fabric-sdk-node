<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: fabric-network/lib/transaction.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: fabric-network/lib/transaction.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Copyright 2018 IBM All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
'use strict';
const Query = require('fabric-network/lib/impl/query/query');
const logger = require('fabric-network/lib/logger').getLogger('Transaction');
const util = require('util');
const noOpTxEventHandler = {
    startListening: async () => { },
    waitForEvents: async () => { },
    cancelListening: () => { }
};
/**
 * Ensure supplied transaction arguments are not strings.
 * @private
 * @static
 * @param {Array} args transaction arguments.
 * @throws {Error} if any arguments are invalid.
 */
function verifyArguments(args) {
    const isInvalid = args.some((arg) => typeof arg !== 'string');
    if (isInvalid) {
        const argsString = args.map((arg) => util.format('%j', arg)).join(', ');
        const msg = util.format('Transaction arguments must be strings: %s', argsString);
        logger.error('verifyArguments:', msg);
        throw new Error(msg);
    }
}
/**
 * Represents a specific invocation of a transaction function, and provides
 * felxibility over how that transaction is invoked. Applications should
 * obtain instances of this class by calling
 * [Contract#createTransaction()]{@link module:fabric-network.Contract#createTransaction}.
 * &lt;br>&lt;br>
 * Instances of this class are stateful. A new instance &lt;strong>must&lt;/strong>
 * be created for each transaction invocation.
 * @memberof module:fabric-network
 * @hideconstructor
 */
class Transaction {
    /*
     * @param {Contract} contract Contract to which this transaction belongs.
     * @param {String} name Fully qualified transaction name.
     */
    constructor(contract, name) {
        this._contract = contract;
        this._name = name;
        this._transactionId = contract.createTransactionID();
        this._transientMap = null;
        this._createTxEventHandler = (() => noOpTxEventHandler);
        this._isInvoked = false;
        this._queryHandler = contract.getNetwork().getQueryHandler();
        this._endorsingPeers = null;
    }
    /**
     * Get the fully qualified name of the transaction function.
     * @returns {String} Transaction name.
     */
    getName() {
        return this._name;
    }
    /**
     * Get the ID that will be used for this transaction invocation.
     * @returns {module:fabric-client.TransactionID} Transaction ID.
     */
    getTransactionID() {
        return this._transactionId;
    }
    /**
     * Set the event handler strategy to be used for this transaction invocation.
     * @private
     * @param {Function} factoryFunction Event handler factory function.
     * @returns {module:fabric-network.Transaction} This object, to allow function chaining.
     */
    setEventHandlerStrategy(factoryFunction) {
        this._createTxEventHandler = factoryFunction;
        return this;
    }
    /**
     * Set transient data that will be passed to the transaction function
     * but will not be stored on the ledger. This can be used to pass
     * private data to a transaction function.
     * @param {Object} transientMap Object with String property names and
     * Buffer property values.
     * @returns {module:fabric-network.Transaction} This object, to allow function chaining.
     */
    setTransient(transientMap) {
        this._transientMap = transientMap;
        return this;
    }
    /**
     * Set the peers that should be used for endorsement when this transaction is submitted to the ledger.
     * @param {ChannelPeer[]} peers Endorsing peers.
     * @returns {module:fabric-network.Transaction} This object, to allow function chaining.
     */
    setEndorsingPeers(peers) {
        this._endorsingPeers = peers;
        return this;
    }
    /**
     * Returns the network from the contract
     * @returns {module:fabric-network.Network}
     */
    getNetwork() {
        return this._contract.getNetwork();
    }
    /**
     * Submit a transaction to the ledger. The transaction function &lt;code>name&lt;/code>
     * will be evaluated on the endorsing peers and then submitted to the ordering service
     * for committing to the ledger.
     * @async
     * @param {...String} [args] Transaction function arguments.
     * @returns {Buffer} Payload response from the transaction function.
     * @throws {module:fabric-network.TimeoutError} If the transaction was successfully submitted to the orderer but
     * timed out before a commit event was received from peers.
     */
    async submit(...args) {
        verifyArguments(args);
        this._setInvokedOrThrow();
        const network = this._contract.getNetwork();
        const channel = network.getChannel();
        const txId = this._transactionId.getTransactionID();
        const options = this._contract.getEventHandlerOptions();
        const eventHandler = this._createTxEventHandler(this, network, options);
        const request = this._buildRequest(args);
        if (this._endorsingPeers) {
            request.targets = this._endorsingPeers;
        }
        const commitTimeout = options.commitTimeout * 1000; // in ms
        let timeout = this._contract.gateway.getClient().getConfigSetting('request-timeout', commitTimeout);
        if (timeout &lt; commitTimeout) {
            timeout = commitTimeout;
        }
        // node sdk will target all peers on the channel that are endorsingPeer or do something special for a discovery environment
        const results = await channel.sendTransactionProposal(request, timeout);
        const proposalResponses = results[0];
        const proposal = results[1];
        // get only the valid responses to submit to the orderer
        const { validResponses } = this._validatePeerResponses(proposalResponses);
        await eventHandler.startListening();
        // Submit the endorsed transaction to the primary orderers.
        const response = await channel.sendTransaction({
            proposalResponses: validResponses,
            proposal
        });
        if (response.status !== 'SUCCESS') {
            const msg = util.format('Failed to send peer responses for transaction %j to orderer. Response status: %j', txId, response.status);
            logger.error('submit:', msg);
            eventHandler.cancelListening();
            throw new Error(msg);
        }
        await eventHandler.waitForEvents();
        return validResponses[0].response.payload || null;
    }
    _setInvokedOrThrow() {
        if (this._isInvoked) {
            throw new Error('Transaction has already been invoked');
        }
        this._isInvoked = true;
    }
    _buildRequest(args) {
        const request = {
            chaincodeId: this._contract.getChaincodeId(),
            txId: this._transactionId,
            fcn: this._name,
            args: args
        };
        if (this._transientMap) {
            request.transientMap = this._transientMap;
        }
        return request;
    }
    /**
     * Check for proposal response errors.
     * @private
     * @param {any} responses the responses from the install, instantiate or invoke
     * @return {Object} number of ignored errors and valid responses
     * @throws if there are no valid responses at all.
     */
    _validatePeerResponses(responses) {
        if (!responses.length) {
            logger.error('_validatePeerResponses: No results were returned from the request');
            throw new Error('No results were returned from the request');
        }
        const validResponses = [];
        const errorResponses = [];
        responses.forEach((responseContent) => {
            if (responseContent instanceof Error) {
                // this is either an error from the sdk, peer response or chaincode response.
                // we can distinguish between sdk vs peer/chaincode by the isProposalResponse flag in the future.
                // TODO: would be handy to know which peer the response is from and include it here.
                logger.warn('_validatePeerResponses: Received error response from peer:', responseContent);
                errorResponses.push(responseContent);
            }
            else {
                // anything else is a successful response ie status will be less then 400.
                // in the future we can do things like verifyProposalResponse and compareProposalResponseResults
                // as part of an extended client side validation strategy but for now don't perform any client
                // side checks as the peers will have to do this anyway and it impacts client performance
                logger.debug('_validatePeerResponses: valid response from peer %j', responseContent.peer);
                validResponses.push(responseContent);
            }
        });
        if (validResponses.length === 0) {
            const errorMessages = errorResponses.map((response) => util.format('peer=%s, status=%s, message=%s', response.peer.name, response.status, response.message));
            const messages = Array.of(`No valid responses from any peers. ${errorResponses.length} peer error responses:`, ...errorMessages);
            const msg = messages.join('\n    ');
            logger.error('_validatePeerResponses: ' + msg);
            throw new Error(msg);
        }
        return { validResponses, invalidResponses: errorResponses };
    }
    /**
     * Evaluate a transaction function and return its results.
     * The transaction function will be evaluated on the endorsing peers but
     * the responses will not be sent to the ordering service and hence will
     * not be committed to the ledger.
     * This is used for querying the world state.
     * @async
     * @param {...String} [args] Transaction function arguments.
     * @returns {Buffer} Payload response from the transaction function.
     */
    async evaluate(...args) {
        verifyArguments(args);
        this._setInvokedOrThrow();
        const channel = this._contract.getNetwork().getChannel();
        const request = this._buildRequest(args);
        const commitTimeout = this._contract.getEventHandlerOptions().commitTimeout * 1000; // in ms
        const timeout = this._contract.gateway.getClient().getConfigSetting('request-timeout', commitTimeout);
        if (timeout &lt; commitTimeout) {
            request.request_timeout = commitTimeout;
        }
        const query = new Query(channel, request);
        return this._queryHandler.evaluate(query);
    }
    /**
     * Create a commit event listener for this transaction.
     * @param {Function} callback - This callback will be triggered when
     *		a transaction commit event is emitted. It takes parameters
     * 		of error, transactionId, transaction status and block number
     * @param {module:fabric-network.Network~ListenerOptions} [options] - Optional. Options on
     * 		registrations allowing start and end block numbers.
     * @param {ChannelEventHub} [eventHub] - Optional. Used to override the event hub selection
     * @returns {module:fabric-network~CommitEventListener}
     * @async
     */
    async addCommitListener(callback, options, eventHub) {
        const txid = this.getTransactionID().getTransactionID();
        const network = this._contract.getNetwork();
        return network.addCommitListener(txid, callback, options, eventHub);
    }
}
module.exports = Transaction;
//# sourceMappingURL=transaction.js.map</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-fabric-network.html">fabric-network</a></li></ul><h3>Classes</h3><ul><li><a href="AffiliationService.html">AffiliationService</a></li><li><a href="BasePackager.html">BasePackager</a></li><li><a href="BasicCommitHandler.html">BasicCommitHandler</a></li><li><a href="BlockDecoder.html">BlockDecoder</a></li><li><a href="CertificateAuthority.html">CertificateAuthority</a></li><li><a href="Chaincode.html">Chaincode</a></li><li><a href="ChaincodeRegistration.html">ChaincodeRegistration</a></li><li><a href="Channel.html">Channel</a></li><li><a href="ChannelEventHub.html">ChannelEventHub</a></li><li><a href="ChannelPeer.html">ChannelPeer</a></li><li><a href="Client.html">Client</a></li><li><a href="CommitHandler.html">CommitHandler</a></li><li><a href="DiscoveryEndorsementHandler.html">DiscoveryEndorsementHandler</a></li><li><a href="EndorsementHandler.html">EndorsementHandler</a></li><li><a href="EndorsementPolicy.html">EndorsementPolicy</a></li><li><a href="Endpoint.html">Endpoint</a></li><li><a href="event_hub_number.html">event_hub_number</a></li><li><a href="FabricCAClient.html">FabricCAClient</a></li><li><a href="FabricCAServices.html">FabricCAServices</a></li><li><a href="IdentityService.html">IdentityService</a></li><li><a href="module-fabric-network.AbstractEventHubSelectionStrategy.html">AbstractEventHubSelectionStrategy</a></li><li><a href="module-fabric-network.AbstractEventListener.html">AbstractEventListener</a></li><li><a href="module-fabric-network.BaseCheckpointer.html">BaseCheckpointer</a></li><li><a href="module-fabric-network.CommitEventListener.html">CommitEventListener</a></li><li><a href="module-fabric-network.Contract.html">Contract</a></li><li><a href="module-fabric-network.ContractEventListener.html">ContractEventListener</a></li><li><a href="module-fabric-network.EventHubDisconnectError.html">EventHubDisconnectError</a></li><li><a href="module-fabric-network.EventHubManager.html">EventHubManager</a></li><li><a href="module-fabric-network.FabricError.html">FabricError</a></li><li><a href="module-fabric-network.FileSystemCheckpointer.html">FileSystemCheckpointer</a></li><li><a href="module-fabric-network.Gateway.html">Gateway</a></li><li><a href="module-fabric-network.HsmX509Provider.html">HsmX509Provider</a></li><li><a href="module-fabric-network.IdentityProviderRegistry.html">IdentityProviderRegistry</a></li><li><a href="module-fabric-network.Network.html">Network</a></li><li><a href="module-fabric-network.Query.html">Query</a></li><li><a href="module-fabric-network.RoundRobinEventHubSelectionStrategy.html">RoundRobinEventHubSelectionStrategy</a></li><li><a href="module-fabric-network.TimeoutError.html">TimeoutError</a></li><li><a href="module-fabric-network.Transaction.html">Transaction</a></li><li><a href="module-fabric-network.Wallet.html">Wallet</a></li><li><a href="module-fabric-network.Wallets.html">Wallets</a></li><li><a href="MSP.html">MSP</a></li><li><a href="MSPManager.html">MSPManager</a></li><li><a href="NetworkConfig_1_0.html">NetworkConfig_1_0</a></li><li><a href="Orderer.html">Orderer</a></li><li><a href="Organization.html">Organization</a></li><li><a href="Peer.html">Peer</a></li><li><a href="Remote.html">Remote</a></li><li><a href="TransactionID.html">TransactionID</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-fabric-network.WalletStore.html">WalletStore</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-app-dev-env-setup.html">Setting up the Application Developer's Environment</a></li><li><a href="tutorial-chaincode-lifecycle.html">fabric-client: How to install and start your chaincode</a></li><li><a href="tutorial-channel-create.html">fabric-client: How to create a Hyperledger Fabric channel</a></li><li><a href="tutorial-channel-events.html">fabric-client: How to use the channel-based event service</a></li><li><a href="tutorial-discovery.html">fabric-client: How to use the discovery service</a></li><li><a href="tutorial-event-checkpointer.html">fabric-network: How to replay missed events</a></li><li><a href="tutorial-event-hub-management.html">fabric-network: How to automatically select and reconnect to event hubs</a></li><li><a href="tutorial-grpc-settings.html">fabric-client: How to set gRPC settings</a></li><li><a href="tutorial-handlers.html">fabric-client: How to use the endorsement and commit handlers</a></li><li><a href="tutorial-listening-to-events.html">fabric-network: How to listen to events</a></li><li><a href="tutorial-logging.html">fabric-client: How to use logging</a></li><li><a href="tutorial-metadata-chaincode.html">fabric-client: How to add CouchDB indexes during chaincode installation</a></li><li><a href="tutorial-mutual-tls.html">fabric-client: How to configure mutual TLS</a></li><li><a href="tutorial-network-config.html">fabric-client: How to use a common connection profile</a></li><li><a href="tutorial-private-data.html">How to use private data</a></li><li><a href="tutorial-query-peers.html">fabric-network: How to select peers for evaluating transactions (queries)</a></li><li><a href="tutorial-sign-transaction-offline.html">Working with an offline private key</a></li><li><a href="tutorial-transaction-commit-events.html">fabric-network: How to wait for transactions to be committed to the ledger</a></li><li><a href="tutorial-wallet.html">fabric-network: Using wallets to manage identities</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CLIENT">CLIENT</a></li><li><a href="global.html#finalPackage">finalPackage</a></li><li><a href="global.html#HFAFFILIATIONMGR">HFAFFILIATIONMGR</a></li><li><a href="global.html#HFGENCRL">HFGENCRL</a></li><li><a href="global.html#HFINTERMEDIATECA">HFINTERMEDIATECA</a></li><li><a href="global.html#HFREGISTRARATTRIBUTES">HFREGISTRARATTRIBUTES</a></li><li><a href="global.html#HFREGISTRARDELEGATEROLES">HFREGISTRARDELEGATEROLES</a></li><li><a href="global.html#HFREGISTRARROLES">HFREGISTRARROLES</a></li><li><a href="global.html#HFREVOKER">HFREVOKER</a></li><li><a href="global.html#loadConfigGroup">loadConfigGroup</a></li><li><a href="global.html#loadConfigValue">loadConfigValue</a></li><li><a href="global.html#ORDERER">ORDERER</a></li><li><a href="global.html#package">package</a></li><li><a href="global.html#PEER">PEER</a></li><li><a href="global.html#toEnvelope">toEnvelope</a></li><li><a href="global.html#USER">USER</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Fri Dec 13 2019 14:19:22 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
